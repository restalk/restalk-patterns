<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" 
      content="The RESTalk Pattern Language for RESTful conversations and the RESTalk DSL for modeling these conversations.">
    <title>RESTalk Patterns - Pattern: Long Running Operation with Polling</title>
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href='https://fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Fira+Mono:400,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Fira+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link type="text/css" rel="stylesheet" href="stylesheets/main.css" />
  </head>
  <body>
    <header>
      <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container">
          <div class="navbar-header">
            <div class="container">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
            </div>
          </div>
          <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav">
              <li><a href="index.html">RESTalk Pattern Language</a></li>
              <li class="dropdown">
                <a href="index.html#patterns" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Patterns <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="post-put.html">POST-PUT Creation</a></li>
                  <li><a href="long-running-operation-polling.html">Long Running Operation with Polling</a></li>
                </ul>
              </li>
              <li><a href="rest.html">REST</a></li>
              <li><a href="dsl.html">RESTalk DSL</a></li>
              <li class="dropdown">
                <a href="more.html" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">More <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="references.html">References</a></li>
                  <li><a href="authors.html">Authors</a></li>
                  <li><a href="contribute.html">Contribute</a></li>
                </ul>
              </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="imprint.html">Imprint &amp; Contact</a></li>
            </ul>
          </div>
        </div>
      </nav>
    </header>
    <div class="content">
      <section class="main container">
        <h1>Long Running Operation with Polling</h1>


<div class="pattern-summary">
    <dl>
        <dt class="h4 without-top-margin">
            Summary:
        </dt>
        <dd>
            Use polling to avoid client timeouts when waiting long running operation results
        </dd>
    </dl>
</div>
<dl>
    <dt class="h4">
        Context:
    </dt>
    <dd>
        Processing complex or data intensive operations (e.g., big data processing, back-up jobs) might require a long time.
    </dd>
    <dt class="h4">
        Problem:
    </dt>
    <dd>
        How can a client retrieve the result of such an operation without keeping the HTTP connection open for a too long time? Especially, as there normally will be a timeout for HTTP connections because every open connection allocates a certain amount of memory at the server and the client. How can we avoid wasting resources for open connections and for computations whose result will not be received by the client in case of a timeout?
    </dd>
    <dt class="h4">
        Forces:
    </dt>
    <dd>
        As the network is not reliable, the client may loose the connection before the server has completed processing the result. The longer the server takes to respond to the client, the higher the chances that the client may no longer be available to receive the result or interested to retrieve it. The server may need to perform expensive computations to process client requests and these would be repeated every time the client resends the request in case the connection on the previous one is dropped. Performing computations and delivering their results are two concerns that make completely different demands on the server infrastructure. 
    </dd>
    <dt class="h4">
        Solution:
    </dt>
    <dd>
        <p>
            The long running operation itself is turned into a resource, created using the original request with a response telling the client where to find the results. These will be available once the operation running in the background completes. The client may poll the resource to GET its current progress, and will eventually be redirected to another resource representing the result, once the long running operation has completed. Since the output has its own URI, it becomes possible to GET it multiple times, as long as it has not been deleted. Additionally, the long running operation can be cancelled with a DELETE request, thus implicitly stopping the operation on the server, or deleting its output if it had already completed in the meanwhile. A visualization of the solution is provided in the following <a href="rest.html">RESTalk</a> diagram:
        </p>
        <p class="text-center">
            <a href="img/long-running-polling.svg">
            <object class="img-small" data="img/long-running-polling.svg" title="Long Running Operation with Polling" alternate="The RESTalk diagram for the Long Running Operation with Polling pattern">
            </object>
            </a> 
        </p>
    </dd>
    <dt class="h4">
        Consequences:
    </dt>
    <dd>
        <p>Benefits:</p>
        <ul class="list-unstyled">
            <li>
                <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
                <em>Scalability:</em> 
                The client does not need to keep the connection open with the server for the entire duration of the request. This has a positive impact on the number of clients that the server can handle concurrently.
            </li>
            <li>
                <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
                <em>Shared results:</em> 
                 The link to the result can be shared among multiple clients that can retrieve it without needing the server to recompute it again for each client.
            </li>
            <li>
                <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
                <em>Request cancellation:</em> 
                 An explicit mechanism consistent with the REST uniform interface is provided for cancelling requests and thus avoiding to waste server resources to perform computations whose results the client is no longer interested in.
            </li>
        </ul>
        <p>Liabilites:</p>
        <ul  class="list-unstyled">
            <li>
                <span class="glyphicon glyphicon-minus" aria-hidden="true"></span>
                <em>Polling:</em> 
                The client needs to implement polling, which if done too frequently, may put an additional burden on the server and consume unnecessary bandwidth. To mitigate this problem, it is possible that the server can provide the client with progress information while it is polling so that the number of GET requests can be reduced. 
            </li>
            <li>
                <span class="glyphicon glyphicon-minus" aria-hidden="true"></span>
                <em>Server storage consumption:</em> 
                 Depending on the type and size of the result, storage space will be consumed if clients forget to delete the job results and these are not deleted automatically after a certain period of time. 
            </li>
        </ul>
    </dd>
    <dt class="h4">
        Variants:
    </dt>
    <dd>
        <p>
            To avoid polling, the client could become a server as well if possible, providing a callback link when starting the job, indicating where it wants to be notified when the result is available. Queuing requests, processing them and delivering the corresponding results may be assigned to separate physical servers, so that the polling by a large number of clients can be directed to a dedicated server.
        </p>
        <p>
           If the first step of this conversations needs to be reliable in case of lost responses, and to avoid creating the same job multiple times, this pattern can be combined with the <em>POST Once Exactly</em> or the <em>POST-PUT Creation</em> pattern where the job is started with the POST or the PUT respectively.
        </p>
    </dd>
    <dt class="h4">
        Known uses:
    </dt>
    <dd>
        <p>
            The <a target="_blank" href="http://docs.aws.amazon.com/amazonglacier/latest/dev/job-operations.html">AWS Glacier REST API</a> as well as an <a target="_blank" href="http://dl.acm.org/citation.cfm?id=2307825">API for handling Virtual Machines</a>.
        </p>
    </dd>
    <dt class="h4">
        Related Patterns:
    </dt>
    <dd>
        <p>
            If the creation of the job resource needs to be reliable the <a href="post-put.html"><em>POST-PUT Creation</em> pattern</a> may help.
        </p>
    </dd>
</dl>


      </section>
    </div>

    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
  </body>
</html>